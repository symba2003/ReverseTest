using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ReverseTest
{
    /// <summary>
    /// Samples from here:
    /// http://www.hanselman.com/blog/FlipTheEndiannessOfALongInC.aspx
    /// 
    /// Task:
    /// Write me a function with this signature in C#:
    /// public (unsafe?) long Reverse(long i, int bits)
    /// ...to flip the endian-ness (LSB/MSB) of a long, but just the # of significant bits specified.
    /// 
    /// Example, if the input is 376, with bits=11, the output is 244 (decimal, base 10).
    /// 376 = 00000101111000
    /// 244 = 00000011110100
    /// 
    /// Example, if the input is 900, with bits=11, the output is 270.
    /// 900 = 00001110000100
    /// 270 = 00000100001110
    /// 
    /// Example, if the input is 900, with bits=12, the output is 540.
    /// 900 = 00001110000100
    /// 540 = 00001000011100
    /// 
    /// Example, if the input is 154, with bits=4, the output is 5.
    /// 154 = 00000010011010
    /// 5   = 00000000000101
    /// And make it FAST...;)
    /// </summary>
    class LongSample
    {
        public static void Run() 
        {
            long l = 3689348814741910323; // 11001100110011001100110011001100110011001100110011001100110011
            // 
            l = 3689548814741911223; // 1101000000110011001100111110100100011001010101000010011110110110 = 0x3333e9195427b6b7
            ReverseValue(l);

            long l1 = Reverse_byWesnerMoise((long)900, 11);
            Console.WriteLine("Reverse_byWesnerMoise reverse for 900 and 11: " + l1);
            Console.WriteLine("ExpectedResult: 270");

            long l2 = Reverse_byWesnerMoise((long)900, 12);
            Console.WriteLine("Reverse_byWesnerMoise reverse for 900 and 12: " + l2);
            Console.WriteLine("ExpectedResult: 540");

            long l3 = Reverse_byWesnerMoise((long)376, 11);
            Console.WriteLine("Reverse_byWesnerMoise reverse for 376 and 11: " + l3);
            Console.WriteLine("ExpectedResult: 244");

            Console.ReadLine();
        }

        private static void ReverseValue(long l) 
        {
            Console.WriteLine("Initial long value: " + l);
            // correct (for samples)
            long l1 = Reverse_byNicholasAllen(l, 64); // 1111111111111111111111111111111111001100110011001100110011001100
            Console.WriteLine("Nicholas Allen reverse: " + l1);
            //correct
            long l2 = Reverse_byWesnerMoise(l, 64);
            Console.WriteLine("WesnerMoise: " + l1);
        }

        public static long Reverse_byNicholasAllen(long i, int bits)
        {
            /** i= 64 63 62 61 60 .... 5 4 3 2 1
             * 1. 0x5555555555555555 = 0101010101010101010101010101010101010101010101010101010101010101
             * (i >> 1) = 0 64 63 62 61 ... 6 5 4 3 2
             *  ((i >> 1) & 0x5555555555555555) = 0 64 0 62 0 60 0 58 ... 6 0 4 0 2
             * i & 0x5555555555555555 = 0 63 0 61 0 59... 5 0 3 0 1
             * ((i & 0x5555555555555555) << 1) = 63 0 61 0 59 0 ...5 0 3 0 1 0
             * ((i >> 1) & 0x5555555555555555) | ((i & 0x5555555555555555) << 1)= 63 64 61 62 59 60 57 58 55 56 53 54 51 52 49 50 47 48 ...27 28 25 26 23 24 21 22 19 20 17 18 15 16 13 14 11 12 9 10 7 8 5 6 3 4 1 2
             * 
             * 2. 0x3333333333333333 = 0011001100110011001100110011001100110011001100110011001100110011
             *    (i >> 2) = 0 0 63 64 61 62 59 60...7 8 5 6 3 4
             *    (i >> 2) & 0x3333333333333333) = 0 0 63 64 0 0 59 60 ... 7 8 0 0 3 4
             *    (i & 0x3333333333333333) = 0 0 61 62 0 0 57 58 ...5 6 0 0 1 2
             *    (i & 0x3333333333333333) << 2 = 61 62 0 0 57 58 0 0 ... 5 6 0 0 1 2 0 0
             *    ((i >> 2) & 0x3333333333333333) | ((i & 0x3333333333333333) << 2) = 61 62 63 64 57 58 59 60 53 54 55 56 49 50 51 52 45 46 47 48  ... 17 18 19 20 13 14 15 16 9 10 11 12 5 6 7 8 1 2 3 4
             *    
             * 3. 0x0F0F0F0F0F0F0F0F = 0000111100001111000011110000111100001111000011110000111100001111
             * (i >> 4) = 0 0 0 0 61 62 63 64 57 58 59 60 .... 5 6 7 8
             * (i >> 4) & 0x0F0F0F0F0F0F0F0F = 0 0 0 0 61 62 63 64 0 0 0 0 53 54 55 56 0 0 0 0 45 46 47 48 .. 0 0 0 0 13 14 15 16 0 0 0 0 5 6 7 8
             * (i & 0x0F0F0F0F0F0F0F0F) = 0 0 0 0 57 58 59 60 0 0 0 0 49 50 51 52... 9 10 11 12 0 0 0 0 1 2 3 4
             * (i & 0x0F0F0F0F0F0F0F0F) << 4 = 57 58 59 60 0 0 0 0 49 50 51 52 ... 17 18 19 20 0 0 0 0 9 10 11 12 0 0 0 0 1 2 3 4 0 0 0 0
             * ((i >> 4) & 0x0F0F0F0F0F0F0F0F) | ((i & 0x0F0F0F0F0F0F0F0F) << 4) = 57 58 59 60 61 62 63 64 49 50 51 52 53 54 55 56 ... 17 18 19 20 21 22 23 24 9 10 11 12 13 14 15 16 1 2 3 4 5 6 7 8
             * 
             * 4. 0x00FF00FF00FF00FF = 0000000011111111000000001111111100000000111111110000000011111111
             *    (i >> 8) = 0 0 0 0 0 0 0 0 57 58 59 60 61 62 63 64 49 50 51 52 53 54 55 56 ... 17 18 19 20 21 22 23 24 9 10 11 12 13 14 15 16
             *    (i >> 8) & 0x00FF00FF00FF00FF) = 0 0 0 0 0 0 0 0 57 58 59 60 61 62 63 64 0 0 0 0 0 0 0 0 ... 25 26 27 28 29 30 31 32 0 0 0 0 0 0 0 0 9 10 11 12 13 14 15 16
             *    (i & 0x00FF00FF00FF00FF) = 0 0 0 0 0 0 0 0 49 50 51 52 53 54 55 56 0 0 0 0 0 0 0 0 ... 17 18 19 20 21 22 23 24 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8
             *    (i & 0x00FF00FF00FF00FF) << 8) = 49 50 51 52 53 54 55 56 0 0 0 0 0 0 0 0 ... 17 18 19 20 21 22 23 24 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 0 0 0 0 0 0 0 0 
             *    ((i >> 8) & 0x00FF00FF00FF00FF) | ((i & 0x00FF00FF00FF00FF) << 8); = 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64... 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
             * ***/
            i = ((i >> 1) & 0x5555555555555555) | ((i & 0x5555555555555555) << 1);
            i = ((i >> 2) & 0x3333333333333333) | ((i & 0x3333333333333333) << 2);
            i = ((i >> 4) & 0x0F0F0F0F0F0F0F0F) | ((i & 0x0F0F0F0F0F0F0F0F) << 4);
            i = ((i >> 8) & 0x00FF00FF00FF00FF) | ((i & 0x00FF00FF00FF00FF) << 8);
            /* 0x0000FFFF0000FFFF = 111111111111111100000000000000001111111111111111
               (i >> 16) = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64... 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
             * (i >> 16) & 0x0000FFFF0000FFFF) = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 ... 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
             * (i & 0x0000FFFF0000FFFF) = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 ... 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
             * (i & 0x0000FFFF0000FFFF) << 16 = 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 ... 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
             * (i >> 16) & 0x0000FFFF0000FFFF) | ((i & 0x0000FFFF0000FFFF) << 16 = 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
             */
            i = ((i >> 16) & 0x0000FFFF0000FFFF) | ((i & 0x0000FFFF0000FFFF) << 16);
            /*
             (i >> 32) | (i << 32) =  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
             */
            i = (i >> 32) | (i << 32);

            // в моем случае: bits = 64 (на все 64 бита сдвигаю)
            return i >> (64 - bits);
        }

        public static long Reverse_byWesnerMoise(long word, int bits)
        {
            // The left shift operator should work the same in C# as in C++.
            // The right shift has two different behavior (arithmetic versus logical shift) depending on whether the type is signed or not.
            // (ulong) >>
            // (long) >>
            // в моем случае: bits = 64 (на все 64 бита сдвигаю)
            ulong n = (ulong)word << (64-bits);
            // n = = 64 63 62 61 60 .... 5 4 3 2 1
            // n >> 32 | n << 32= 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33
            n = n >> 32 | n << 32;
            // 0x0000ffff = 00000000000000001111111111111111
            // Operator precedence: 1) << >> 2) & 3) |
            // n >> 0xf = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48
            //  n << 0xf = 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33
            //  n >> 0xf & 0x0000ffff = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0  0 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48
            //  n << 0xf & 0xffff0000 = 
            //COMMENT1: ошибка в алгоритме! Первым шагом сдвигается на 0xf = 15, а надо на 0x10
            // COMMENT2: еще одна ошибка: алгоритм работает только на маленьких числах корректно (когда старшие 32бита - нулевые)
            // Если же старшие 32 бита ненулевые - онибудут занулены при первой же  операции "& 0x0000ffff "
            // TODO: скорректировать алогритм для работы с большими числами (64битными)
            // TODO: получился одинаковый результат с Reverse_byNicholasAllen .Почему?? корректны ли они все таки
            //n = n >> 0xf & 0x0000ffff | n << 0xf & 0xffff0000; // 0xf = 15 = 1111 (а должно быть, наверное 10000 = 16 = 0x10)


            // n >> 0x10 = 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49
            // n >> 0x10 & 0x0000ffff = 0 ... 0 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49
            // n << 0x10 = 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33
            //  n << 0x10 & 0xffff0000 = 0... 0 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 00000000 00000000
            // n = n >> 0x10 & 0x0000ffff | n << 0x10 & 0xffff0000 = 0... 0 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49
            n = n >> 0x10 & 0x0000ffff | n << 0x10 & 0xffff0000;
            n = n >> 0x8 & 0x00ff00ff | n << 0x8 & 0xff00ff00; // 0x8 = 8 = 1000
            n = n >> 0x4 & 0x0f0f0f0f | n << 0x4 & 0xf0f0f0f0; // 0x4 = 4= 100
            n = n >> 0x2 & 0x33333333 | n << 0x2 & 0xcccccccc;
            n = n >> 0x1 & 0x55555555 | n << 0x1 & 0xaaaaaaaa;
            return (long) n | word & (-1 << bits);

            /* Sample: long value is 3689548814741911223
             * 3689548814741911223 = 0x3333e9195427b6b7 = 00110011 00110011 11101001 00011001 01010100 00100111 10110110 10110111
1. 6064016321231972633 = 5427B6B73333E919 = 01010100 00100111 10110110 10110111 00110011 00110011 11101001 00011001
					 0101010000100111101101101011011100110011001100111110100100011001

2. 					
n >> 0x10 & 0x0000ffff = (00000000 00000000 01010100 00100111 10110110 10110111 00110011 00110011) & 1111111111111111 = 
			= 00000000 00000000 00000000 00000000 00000000 00000000 00110011 00110011

 n << 0x10  & 0xffff0000 = (10110110 10110111 00110011 00110011 11101001 00011001 00000000 00000000) & 0xffff0000 =
			= 00000000 00000000 00000000 00000000 00000000 00000000 11101001 00011001 00000000 00000000

n = n >> 0x10 & 0x0000ffff | n << 0x10 & 0xffff0000:
n = 00000000 00000000 00000000 00000000 00000000 00000000 11101001 00011001 00110011 00110011 (00000000000000000000000000000000000000000000000011101001000110010011001100110011)



n >> 0x10 & 0x0000ffff = (00005427B6B73333) & 0x0000ffff = 0000000000003333
n << 0x10  & 0xffff0000 = B6B73333E9190000  & 0xffff0000 = 00000000E9190000
n = n >> 0x10 & 0x0000ffff | n << 0x10 & 0xffff0000= 00000000E9193333
Результат: 00000000E9193333


3.  n = n >> 0x8 & 0x00ff00ff | n << 0x8 & 0xff00ff00;
n >> 0x8 = 00000000E91933
n >> 0x8 & 0x00ff00ff = 00000000E90033
n << 0x8 = 000000E919333300
n << 0x8 & 0xff00ff00 = 0000000019003300
n = n >> 0x8 & 0x00ff00ff | n << 0x8 & 0xff00ff00 = 0000000019E93333

4. n >> 0x4 & 0x0f0f0f0f | n << 0x4 & 0xf0f0f0f0;
n >> 0x4  		= 00000000019E9333
n >> 0x4 & 0x0f0f0f0f 	= 00000000010E0303
n << 0x4		= 000000019E933330
n << 0x4 & 0xf0f0f0f0	= 0000000090903030
n >> 0x4 & 0x0f0f0f0f | n << 0x4 & 0xf0f0f0f0 = 00000000919E3333

5. n >> 0x2 & 0x33333333 | n << 0x2 & 0xcccccccc;
n >> 0x2 = 00000000 919E3333 = 0...0 10010001 10011110 00110011 00110011 >> 0x2 =  0...0 00100100 01100111 10001100 11001100
n >> 0x2 & 0x33333333 = n >> 0x2 & 0x33333333 = 0...0 00100100 01100111 10001100 11001100 & 00110011 00110011 00110011 00110011 = 0...0 00100000 00100011 00000000 00000000 = 0x20230000
n << 0x2 = 0...0 10010001 10011110 00110011 00110011 << 0x2 = 0..010 01000110 01111000 11001100 11001100 = 0x24678CCCC = (1001000110011110001100110011001100) 
n << 0x2 & 0xcccccccc = 0..010 01000110 01111000 11001100 11001100 & 11001100 11001100 11001100 11001100 = 0..0 01000100 01001000 11001100 11001100
n >> 0x2 & 0x33333333 | n << 0x2 & 0xcccccccc = 0..0 01100100 01101011 11001100 11001100 = 0x646BCCCC (01100100011010111100110011001100)

6.  n >> 0x1 & 0x55555555 | n << 0x1 & 0xaaaaaaaa;
n >> 0x1 = 00110010001101011110011001100110
n >> 0x1 & 0x55555555 = 00110010001101011110011001100110 & 01010101010101010101010101010101 = 00010000 00010101 01000100 01000100 
n << 0x1 = 11001000110101111001100110011000
n << 0x1 & 0xaaaaaaaa = 11001000110101111001100110011000 & 10101010101010101010101010101010 = 10001000 10000010 10001000 10001000 
n >> 0x1 & 0x55555555 | n << 0x1 & 0xaaaaaaaa = 10011000 10010111 11001100 11001100 = 0x9897CCCC (10011000100101111100110011001100 )
             * 
             * 
7. (long) n | word & (-1 << bits);
-1 = 0xffffffff
-1 << bits = 0xffffffff
word & (-1 << bits) = 01010100 00100111 10110110 10110111 (01010100001001111011011010110111)  = 0x5427B6B7 (01010100 00100111 10110110 10110111)
(видимо -1 - implicitly cust to long, так как после этой операции в vs результат: 0x3333e9195427b6b7
(long) n | word & (-1 << bits) = n = старш 32 бита : 0x3333e919 и младшие 32 бита 10011000 10010111 11001100 11001100 = 0x3333e919 и 11011100 10110111 11111110 11111111 = 0x3333e919DCB7FEFF
             * Получился результат: 0x3333e919DCB7FEFF


Результат должен быть:
11101101 01101101 11100100 00101010 10011000 10010111 11001100 11001100
1110110101101101111001000010101010011000100101111100110011001100 = 0xED6DE42A9897CCCC (младшие 32бит соответствует результату, полученному в п.6)




             * ***/

            //ulong n = (ulong)word {{ (64-bits);
            //n = n }} 32 | n {{ 32;
            //n = n }} 0xf & 0x0000ffff | n {{ 0xf & 0xffff0000;
            //n = n }} 0x8 & 0x00ff00ff | n {{ 0x8 & 0xff00ff00;
            //n = n }} 0x4 & 0x0f0f0f0f | n {{ 0x4 & 0xf0f0f0f0;
            //n = n }} 0x2 & 0x33333333 | n {{ 0x2 & 0xcccccccc;
            //n = n }} 0x1 & 0x55555555 | n {{ 0x1 & 0xaaaaaaaa;
            //return (long) n | word & (-1 {{ bits);
        }
    }
}
